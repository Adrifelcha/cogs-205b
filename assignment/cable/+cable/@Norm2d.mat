classdef Norm2d
    % Bivariate normal likelihood equivalence class
    properties
        Mean(2,1) double
        Covariance(2,2) double
        Precision(2,2) double
        Correlation double
    end
    
    methods
        % Constructor
        function obj = Norm2d(mu,sigma)
            % May need to do this as varargin
            % Set default values
            if nargin < 1
                mu = [0;0];
                sigma = ones(2);
            elseif nargin < 2
                sigma = ones(2);
            end
            
            obj.Mean = mu;
            obj.Covariance = sigma;
        end
        
        % Math stuff
        function pdfOut = pdf(X,Mu,Sigma)
            % Calculate the probability density function
            % X is a 2xn matrix
            % pdfOut is a 1xn matrix
            if nargin < 2
                Mu = [0;0];
                Sigma = ones(2);
            elseif nargin < 3
                Sigma = ones(2);
            end
            rho = Sigma(1,2) / sqrt(Sigma(1,1) * Sigma(2,2));
            sigma1 = sqrt(Sigma(1,1));
            sigma2 = sqrt(Sigma(2,2));
            z = ((X(1,:) - Mu(1))/sigma1)^2 - ...
                2 * rho * ((X(1,:) - Mu(1))/sigma1) * ...
                ((X(2,:) - Mu(2))/sigma2) + ...
                ((X(2,:) - Mu(2))/sigma2)^2;
            pdfOut = 1/(2*pi*sigma1*sigma2*sqrt(1 - rho^2)) * ...
                exp((-1/2) * z/(1 - rho^2));
        end
        function logpdfOut = logpdf(X,Mu,Sigma)
            % DON'T just take the log of pdfOut
            % That is technically what you do, but simplify the equation???
            
        end
        function cdfOut = cdf(X,Mu,Sigma)
            % freebie
            cdfOut = mvncdf(X,Mu,Sigma);
        end
        function logcdfOut = logcdf(X,Mu,Sigma)
            % freebie
            logcdfOut = log(mvncdf(X,Mu,Sigma));
        end
        function sample = rng(Mu,Sigma,size)
            % Pull a random sample from this distribution
            
        end
        function dev = deviance(Data,Mu,Sigma)
            % Data is an n*2 matrix (2 cols, n rows)
            X = linspace(1,size(Data,1),size(Data,1));
            X = [X,X];
            dev = (-2) * sum(logpdf(X,Mu,Sigma),'all');
        end
        
        % Getters
        function meanOut = get.Mean(obj)
            meanOut = obj.Mean;
        end
        function covarOut = get.Covariance(obj)
            covarOut = obj.Covariance;
        end
        function precisionOut = get.Precision(obj)
            precisionOut = obj.Precision;
        end
        function corrOut = get.Correlation(obj)
            corrOut = obj.Correlation;
        end
        
        % Setters
        function obj = set.Mean(obj,val)
%             if size(val) ~= [2,2]
%                 check = FALSE;
%                 while check == FALSE
%                     % check
%                     if size(val) == [2,2]
%                         check = TRUE;
%                     end
%                 end
%             end
            
            obj.Mean = val;
            obj = updateMean(obj); % Derivatives
        end
        function obj = set.Covariance(obj,val)
            obj.Covariance = val;
            obj = updateCovar(obj);
        end
    end
    
    % Hidden methods
    methods (Access = private)
        % Update derivative values
        function obj = updateMean(obj)
            % Recalculate values that rely on obj.Mean
            
        end
        function obj = updateCovar(obj)
            % Recalculate values that rely on obj.Covariance
            % Precision is the inverse of Covar
                % Make sure it is invertible first!!
            obj.Precision = inv(obj.Covariance);
            obj.Correlation = obj.Covariance(1,2) / sqrt(obj.Covariance(1,1) * obj.Covariance(2,2));
        end
    end
end
